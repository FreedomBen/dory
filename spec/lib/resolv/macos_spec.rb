require 'rspec'

RSpec.describe Dory::Resolv::Macos do
  let(:resolv_dir) { '/tmp/resolver' }
  let(:resolv_file) { 'dory' }
  let(:system_resolv_file) { '/tmp/resolv.conf' }
  let(:filename) { '/tmp/resolver/dory' }

  let(:ubuntu_resolv_file_contents) do
    %q(
      # Dynamic resolv.conf(5) file for glibc resolver(3) generated by resolvconf(8)
      #     DO NOT EDIT THIS FILE BY HAND -- YOUR CHANGES WILL BE OVERWRITTEN
      nameserver 10.0.34.17
      nameserver 10.0.34.16
      nameserver 10.0.201.16
      search corp.instructure.com
    ).split("\n").map{|s| s.gsub(/^\s+/, '')}.join("\n")
  end

  let(:stub_resolv_file) do
    ->() do
      allow(Dory::Resolv::Macos).to receive(:resolv_dir) { resolv_dir }
      allow(Dory::Resolv::Macos).to receive(:resolv_file_name) { resolv_file }
      allow(Dory::Resolv::Macos).to receive(:system_resolv_file) { system_resolv_file }
      # make sure we aren't going to over-write the real resolv file
      expect(Dory::Resolv::Macos.resolv_file).to eq(filename)
      expect(Dory::Resolv::Macos.system_resolv_file).to eq(system_resolv_file)
    end
  end

  let(:set_macos) do
    ->() do
      allow(Dory::Os).to receive(:macos?){ true }
      allow(Dory::Os).to receive(:ubuntu?){ false }
      allow(Dory::Os).to receive(:fedora?){ false }
      allow(Dory::Os).to receive(:arch?){ false }
    end
  end

  context "creating and deleting the file" do
    before :each do
      stub_resolv_file.call()
      # To add an extra layer of protection against modifying the
      # real resolv file, make sure it matches
      expect(Dory::Resolv::Macos.resolv_file).to eq(resolv_file)
      File.delete(Dory::Resolv::Macos.resolv_file) if File.exists?(Dory::Resolv::Macos.resolv_file)
      expect(File.exists?(Dory::Resolv::Macos.resolv_file)).to be_falsey
    end

    it "creates the file with the nameserver in it" do
      expect{Dory::Resolv::Macos.configure}.to change{
        File.exists?(Dory::Resolv::Macos.resolv_file)
      }.from(false).to(true)
      expect(File.read(Dory::Resolv::Macos.resolv_file)).to match(/added.by.dory/)
    end

    it "cleans up properly" do
      expect{Dory::Resolv::Macos.configure}.to change{
        File.exists?(Dory::Resolv::Macos.resolv_file)
      }.from(false).to(true)
      expect{Dory::Resolv::Macos.clean}.to change{
        File.exists?(Dory::Resolv::Macos.resolv_file)
      }.from(true).to(false)
    end
  end

  context "Seeing system settings" do
    it "knows if we are in the resolv file" do
      # TODO check to see if the changes we wrote to the resolv file
      # were propagated into the system resolv file
    end

    it "knows if we are not in the resolv file" do

    end
  end

  context "knows if we've edited the file" do
    let (:comment) { '# added by dory' }

    let (:stub_resolv) do
      ->(nameserver, file_comment = comment) do
        allow(Dory::Resolv).to receive(:nameserver){ nameserver }
        allow(Dory::Resolv).to receive(:file_comment){ comment }
        expect(Dory::Resolv.nameserver).to eq(nameserver)
        expect(Dory::Resolv.file_comment).to eq(comment)
      end
    end

    %w[127.0.0.1 192.168.53.164].each do |nameserver|
      # Note:  This addresses a bug encountered on Fedora 23 Cloud
      it "doesn't think we edited the file if 127.0.0.1 is there but the comment isn't" do
        stub_resolv.call(nameserver)
        contents = "nameserver 1.1.1.1\nnameserver #{nameserver}\nnameserver 2.2.2.2"
        expect(Dory::Resolv.contents_has_our_nameserver?(contents)).to be_falsey
      end

      it "does think we edited the file if 127.0.0.1 is there but the comment isn't" do
        stub_resolv.call(nameserver)
        contents = "nameserver 1.1.1.1\n#{comment}\nnameserver #{nameserver}\nnameserver 2.2.2.2"
        expect(Dory::Resolv.contents_has_our_nameserver?(contents)).to be_truthy
      end
    end
  end
end
